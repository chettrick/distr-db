// wl_generator.cpp
// Used to mimick front end of CSC462 front-end when 
// stress testing the system

#include <iostream>
#include <string>
#include <functional>
#include <thread>
#include "ra/queue.hpp"
#include "ra/thread_pool.hpp"
#include <curl/curl.h>


using namespace std;
     
// Factory function
// This returns a lambda function that inserts a record in the database system
auto make_post_function(std::string name, std::string descr, std::string date) {
	return [name, descr, date]()
	{
		CURL *curl;
		CURLcode res;
		curl = curl_easy_init();
		std::string post_data = "{\"name\":\"" + name + "\",\"date\":\"" + date + "\"}";
		std::cout << "post data: " << post_data << std::endl;

		if(curl) {
			struct curl_slist *slist1 = NULL;
			slist1 = curl_slist_append(slist1, "Content-Type: application/json");
			curl_easy_setopt(curl, CURLOPT_URL, "http://trans-srv:5555/api/movies");
			curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);

			curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data.c_str());
			curl_easy_setopt(curl, CURLOPT_HTTPHEADER, slist1);
			curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST");

			// Now actually perform the http request
			res = curl_easy_perform(curl);
		}
		curl_easy_cleanup(curl);
	};
}

// Factory function
// This returns a lambda function that queries the database for a record with
// a particular id
// Note: this is a purely performance-related test.  A user would not normally
// search by this id since it is generated by the PostgreSQL database upon writing
auto make_get_function(const unsigned long long id) {
	return [id]()
	{
		CURL *curl;
		CURLcode res;
		curl = curl_easy_init();
		std::string get_url = "http://trans-srv:5555/api/movies/" + std::to_string(id);
		std::cout << "GET URL: " << get_url << std::endl;

		if(curl) {
			curl_easy_setopt(curl, CURLOPT_URL, get_url.c_str());
			curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

			// make the actual GET request
			res = curl_easy_perform(curl);
		}
		curl_easy_cleanup(curl);
	};
}

// create a series of http POST requests, these will cause records to be written
// to the movies table.
// num_records determines how many records are to be added
void add_records(	ra::concurrency::thread_pool &tp,
			const unsigned long long num_records,
			const std::string init_name,
			const std::string init_descr,
			const std::string init_date) {
	for(unsigned long long i = 0; i < num_records; ++i) {
		std::cout << "current movie name: " << (init_name + std::to_string(i)) << std::endl;

		// Create args for the factory function,
		// these will be the values in this specific record
		auto suffix = std::to_string(i);
		auto cur_name = init_name + suffix,
		     cur_descr = init_descr + suffix,
		     cur_date = init_date + suffix;
		auto cur_fun = make_post_function(cur_name, cur_descr, cur_date);
		tp.schedule(cur_fun);
	}
}

// used to perform a series of http GET requests to the transaction server.
// Note: this is the method of performing queries on the database.
void query_records(	ra::concurrency::thread_pool &tp,
			const unsigned long long num_records) {
	// start from 1, as the PostgreSQL server begins labelling id starting at 1
	for(unsigned long long i = 1; i <= num_records; ++i) {
		auto cur_fun = make_get_function(i);
		tp.schedule(cur_fun);
	}
}

// This function writes a series of records to the movies table
// by placing this in a function and creating the thread pool
// inside the function, it is guaranteed that when this function
// returns, all tasks performed here have been completed.
// To elaborate - the thread pool destructor ensures that all
// tasks are complete by closing the thread pool and joining on
// all the threads.  The threads will only return when 2 conditions
// are met: 
// 1 - the thread pool status is set to closed
// 2 - the task queue is empty
void add_data_set_1() {
	const int NUM_THREADS = 5;
	const unsigned long long num_records = 5;
	ra::concurrency::thread_pool tp(NUM_THREADS);
	add_records(tp, num_records, "movie_name", "movie_description", "2019");

}

// read_data_set_1 function makes a series of queries to the data
// written by the function add_data_set_1
void read_data_set_1() {
	const int NUM_THREADS = 5;
	const unsigned long long num_records = 5;
	ra::concurrency::thread_pool tp(NUM_THREADS);
	query_records(tp, num_records);
}

// this test will make queries on pre-existing data while concurrently
// adding new data.  The new data will not be queried at this time.
// This guarantees that all queries are being made on data that exists.
//void add_and_read() {
//
//}

int main()
{
	// No idea why, but the compiler complains unless I create and join on a thread
	// so this code (3 lines) below is here just to keep gcc happy...  
	std::function<void()> fun = []() {std::cout << "running wl_generator" << std::endl;};
	std::thread t1(std::move(fun));
	t1.join();

	// write a set of data to the database
	add_data_set_1();
	// query the set of records written in add_data_set_1()
	read_data_set_1();

	std::cout << "finished tester, queue and threadpool made" << std::endl;
	return 0;
}

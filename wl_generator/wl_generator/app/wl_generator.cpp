// wl_generator.cpp
// Used to mimick front end of CSC462 front-end when 
// stress testing the system

#include <iostream>
#include <string>
#include <string.h>
#include <functional>
#include <thread>
#include "ra/queue.hpp"
#include "ra/thread_pool.hpp"
#include <curl/curl.h>

void usage() {
	std::cout << "Usage:\n" <<
		"To make a series of writes:\n" << 
		"$ -w num_records starting_id\n\n" <<
		"To make a series of queries:\n" <<
		"$ -r num_records starting_id [id | name]\n\n" <<
		"To make a series of reads and writes concurrently:\n" << 
		"$ -rw num_records starting_id global_id [id | name]" << std::endl;
}

// Factory function
// This returns a lambda function that inserts a record in the database system
auto make_post_function(std::string name, std::string descr, std::string date) {
	return [name, descr, date]()
	{
		CURL *curl;
		CURLcode res;
		curl = curl_easy_init();
		std::string post_data = "{\"name\":\"" + name + "\",\"date\":\"" + date + "\"}";
		std::cout << "post data: " << post_data << std::endl;

		if(curl) {
			struct curl_slist *slist1 = NULL;
			slist1 = curl_slist_append(slist1, "Content-Type: application/json");
			curl_easy_setopt(curl, CURLOPT_URL, "http://trans-srv:5555/api/movies");
			curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);

			curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data.c_str());
			curl_easy_setopt(curl, CURLOPT_HTTPHEADER, slist1);
			curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST");

			// Now actually perform the http request
			res = curl_easy_perform(curl);
		}
		curl_easy_cleanup(curl);
	};
}

// Factory function
// This returns a lambda function that queries the database for a record with
// a particular id
// Note: this is a purely performance-related test.  A user would not normally
// search by this id since it is generated by the PostgreSQL database upon writing
auto make_get_function(const unsigned long long id) {
	return [id]()
	{
		CURL *curl;
		CURLcode res;
		curl = curl_easy_init();
		std::string get_url = "http://trans-srv:5555/api/movies/" + std::to_string(id);
		std::cout << "GET URL: " << get_url << std::endl;

		if(curl) {
			curl_easy_setopt(curl, CURLOPT_URL, get_url.c_str());
			curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

			// make the actual GET request
			res = curl_easy_perform(curl);
		}
		curl_easy_cleanup(curl);
	};
}

// create a series of http POST requests, these will cause records to be written
// to the movies table.
// num_records determines how many records are to be added
void add_records(	ra::concurrency::thread_pool &tp,
			const unsigned long long num_records,
			const std::string init_name,
			const std::string init_descr,
			const std::string init_date) {
	for(unsigned long long i = 1; i <= num_records; ++i) {
		std::cout << "current movie name: " << (init_name + std::to_string(i)) << std::endl;

		// Create args for the factory function,
		// these will be the values in this specific record
		auto suffix = std::to_string(i);
		auto cur_name = init_name + suffix,
		     cur_descr = init_descr + suffix,
		     cur_date = init_date + suffix;
		auto cur_fun = make_post_function(cur_name, cur_descr, cur_date);
		tp.schedule(cur_fun);
	}
}

// used to perform a series of http GET requests to the transaction server.
// Note: this is the method of performing queries on the database.
void query_records(	ra::concurrency::thread_pool &tp,
			const unsigned long long num_records) {
	// start from 1, as the PostgreSQL server begins labelling id starting at 1
	for(unsigned long long i = 1; i <= num_records; ++i) {
		auto cur_fun = make_get_function(i);
		tp.schedule(cur_fun);
	}
}

// This function writes a series of records to the movies table
// by placing this in a function and creating the thread pool
// inside the function, it is guaranteed that when this function
// returns, all tasks performed here have been completed.
// To elaborate - the thread pool destructor ensures that all
// tasks are complete by closing the thread pool and joining on
// all the threads.  The threads will only return when 2 conditions
// are met: 
// 1 - the thread pool status is set to closed
// 2 - the task queue is empty
void add_data_set(unsigned long long num_records, unsigned long long starting_id) {
	const int NUM_THREADS = 5;
	ra::concurrency::thread_pool tp(NUM_THREADS);

	// TODO: make use of starting_id (add arg to add_records)
	add_records(tp, num_records, "movie_name", "movie_description", "2019");

}

// read_data_set_1 function makes a series of queries to the data
// written by the function add_data_set_1
void read_data_set_1() {
	const int NUM_THREADS = 5;
	const unsigned long long num_records = 50;
	ra::concurrency::thread_pool tp(NUM_THREADS);
	query_records(tp, num_records);
}

// this test will make queries on pre-existing data while concurrently
// adding new data.  The new data will not be queried at this time.
// This guarantees that all queries are being made on data that exists.
//
// NOTE: the new data being added will start at an offset equal to the
// total data set.  (this accomidates concurrent use of several wl_generators)
//
// FOR EXAMPLE: assume the following parameters:
// global_num_records = 1'000'000'000
// local_num_records = 200'000'000
// starting_id = 400'000'000
// 1 billion records are being read and written in total, across all wl_generators, but this
// instance of the wl_generator is only reading/writing 200 million records (4 other
// wl_generator containers are being run elsewhere).  This wl_generator's starting
// index is 400 million, so the writes will begin at index 1.4 billion.  This will
// ensure that the originally written 1 billion records remain untouched by this process
// and the read tasks will always find a valid record.
void write_and_read(	const unsigned long long global_num_records,
			const unsigned long long local_num_records,
			const unsigned long long starting_index) {

	const int NUM_THREADS = 5;
	ra::concurrency::thread_pool tp(NUM_THREADS);

	std::string 	init_name = "movie_name",
			init_descr = "movie_description",
			init_date = "2019";

	// determine starting write location
	for(		unsigned long long write_index = global_num_records + starting_index,
			read_index = starting_index; 
			read_index < starting_index + local_num_records;
			++write_index, ++read_index) {

		auto 	suffix = std::to_string(write_index);
		auto 	cur_post_name = init_name + suffix,
			cur_post_descr = init_descr + suffix,
			cur_post_date = init_date + suffix;

		// create write lambda function and schedule it
		auto cur_post_fun = make_post_function(cur_post_name, cur_post_descr, cur_post_date);
		tp.schedule(cur_post_fun);

		// create query lambda function and schedule it
		auto cur_get_fun = make_get_function(read_index);
		tp.schedule(cur_get_fun);
	}
}

int main(int argc, char **argv)
{
	// No idea why, but the compiler complains unless I create and join on a thread
	// so this code (3 lines) below is here just to keep gcc happy...  
	std::function<void()> fun = []() {std::cout << "running wl_generator" << std::endl;};
	std::thread t1(std::move(fun));
	t1.join();


	// Parse/sanitize args
	if(argc < 4) {
		std::cout << "too few args: " << argc << std::endl;
		usage();
	}
	if (strcmp(argv[1], "-w") == 0) {
		std::cout << "-r arg provided" << std::endl;
		unsigned long long 	num_records = strtoull(argv[2], nullptr, 10);
		unsigned long long	starting_id = strtoull(argv[3], nullptr, 10);
		std::cout << "num_records: " << num_records << "\nstarting_id: " << starting_id << std::endl;
		add_data_set(num_records, starting_id);
	} else if (strcmp(argv[1], "-r") == 0) { 
		std::cout << "-r arg provided" << std::endl;
	} else if (strcmp(argv[1], "-rw") == 0) { 
		std::cout << "-rw arg provided" << std::endl;
	} else {
		usage();
	}
	
	// write a set of data to the database
//	add_data_set_1();
	// query the set of records written in add_data_set_1()
//	read_data_set_1();
	// concurrently write and query the database
//	write_and_read(50, 50, 1);

	std::cout << "finished tester, queue and threadpool made" << std::endl;
	return 0;
}
